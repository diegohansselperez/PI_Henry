/// <reference types="node"/>
import * as stream from 'stream';
import {ZlibOptions} from 'zlib';

declare namespace gzipSize {
	type Options = ZlibOptions;

	interface GzipSizeStream extends stream.PassThrough {
		addListener(event: 'gzip-size', listener: (size: number) => void): this;
		addListener(
			event: string | symbol,
			listener: (...args: any[]) => void
		): this;
		on(event: 'gzip-size', listener: (size: number) => void): this;
		on(event: string | symbol, listener: (...args: any[]) => void): this;
		once(event: 'gzip-size', listener: (size: number) => void): this;
		once(event: string | symbol, listener: (...args: any[]) => void): this;
		removeListener(event: 'gzip-size', listener: (size: number) => void): this;
		removeListener(
			event: string | symbol,
			listener: (...args: any[]) => void
		): this;
		off(event: 'gzip-size', listener: (size: number) => void): this;
		off(event: string | symbol, listener: (...args: any[]) => void): this;
		emit(event: 'gzip-size', size: number): boolean;
		emit(event: string | symbol, ...args: any[]): boolean;
		prependListener(event: 'gzip-size', listener: (size: number) => void): this;
		prependListener(
			event: string | symbol,
			listener: (...args: any[]) => void
		): this;
		prependOnceListener(
			event: 'gzip-size',
			listener: (size: number) => void
		): this;
		prependOnceListener(
			event: string | symbol,
			listener: (...args: any[]) => void
		): this;

		/**
		Contains the gzip size of the stream after it is finished. Since this happens asynchronously, it is recommended you use the `gzip-size` event instead.
		*/
		gzipSize?: number;
	}
}

declare const gzipSize: {
	/**
	Get the gzipped size of a string or buffer.

	@retu